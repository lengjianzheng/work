1、字节序分为：大端序和小端序
对于多个字节的对象，如果其内存布局中低的有效位存放在低地址，高的有效位存放在高地址则为小端序；否则，为大端序。
我们的机器一般为小端序，网络传输一般为大端序。可以通过简单编码分辨:
int i = 1;
char *p = (char *)i;
if( (int)*p == 1)
	cout<<"little end"<<endl;
else
	cout<<"big end"<<endl;

2、输出一个变量的内存布局
int i;         //int 可以为任一类型
vector<int> v; //保存变量在内存从低到高的每一位
for(int j = 0;j < sizeof(int);j++)
	v.push_back(((i & (1<<j))>>j) & 1);
	
位运算符的法则很简单：
 (1)i<<n:表达式结果为将i向左移n位，左边补0.
 (2)i>>n:表达式结果为将i向右移n位，右边补0或者符号位。所以负数右移，要小心。

3、整型：bool,char,short,int,long,long long
bool	1个字节
char	1个字节
short	2个字节
int		4个字节
long	4个或8个字节
long long	8个字节
(1)C++标准没有规定short <= int <= long具体的字节数。但是32位和64位一般都是上述字节数。除了long，32位平台是4字节、64位平台是8字节。
注意：32位机器整数常量默认4个字节，所以要给长长整形赋值要加相应的后缀，long long int lli = 8618620186439LL;64位则不用。
(2)bool虽然占一个字节，但是赋值的结果只会是0和1(非0，包括负数).
(3)范围：
int             -2147483648 ~ +2147483647   (4 Bytes) 21亿
unsigned int         0 ~ 4294967295    (4 Bytes)   也就能表示10位，42亿
int表示的一段范围连续的整数，所以表示的整数数量和最大值没有必然关系。只不过范围从0开始的话，表示的数量就是最大值加1。占用的字节数决定了表示的整数数量。
(4)赋值(包括初始化)和使用
赋值只是根据类型的存储规则对变量的内存进行写入、：char c1 = -1;和char c1 = 255;结果是一样的，c1的内存都是11111111。
使用则是将内存中的数据根据使用时的规则进行解释、使用，只不过有时会做强制或隐式的类型转换：
int i = 266;
char *c = (char *)&i;
cout<<*c<<endl;虽然i是int类型，当可以通过强制转换将内存中的数据按照我们的意愿使用。
不管原先是什么类型，只要写入内存都是无差别的二进制位。只不过当使用时的类型和原来类型不能自动转换时编译器会做检查和警告，但也不能阻挡我们进行强制转换。

所以，unsigned与否，并没有什么实质作用，对于赋值并没有什么实质作用，仅仅是提醒，可以给unsigned赋-1。
使用的时候也一样，可以当做有符号的变量使用。

编程常用这6中整形。浮点型一律由double就行，基本都够用。只不过double的内存布局不同罢了。

