C++ 学到最后，就是学编译器。汇编指令就那么多，就看编译器怎么解析了。如果你实现编译器，会怎么实现，遇到问题这样想一下，有利于问题的解决。

1、变量
类型：内置类型(整型、浮点型和void)、复合型(指针、引用)和自定义数据结构(struct、class)
字面值：40、true都是字面值，编译器根据字面值的形式和值决定其类型。也可以指定一些字面值的类型如：8618620186439ULL
变量：表示一段具有名字、可以操作的内存空间。
	(0)定义：类型 变量名；为了支持分离式编译，一个变量可以一处(文件)定义，多处(文件)声明、通过extern表示声明。从使用的意义来讲，只有全局变量进行分离式编译才有意义。
	(1)初始化和赋值：初始化是分配一块内存的同时，给内存赋一个值；赋值是为一个已经存在的内存赋一个新值。
	   默认初始化：根据变量类型和位置不同，类的初始化是自定义，内置类型和指针在函数(或语句块)外是0，函数内是随机。引用定义时必须显式初始化。
	(3)内存布局：全局区存放全局变量(函数或语句块之外的变量)和静态局部变量(静态全局变量也算是全局变量吧)，可见性默认extern属性；栈：局部变量；堆：new或者malloc出来的变量。
引用和指针：引用即使别名，所以引用定义时必须有一个显式的对象。引用的类型要与所绑定的类型严格匹配，一些const引用的情况除外。
			引用的底层实现还是指针，通过编译器编译后的汇编代码可以看出。即编译过程中，遇到引用都是变成对引用所绑定对象的地址的操作，所以没有引用这个变量即引用不是变量。
			指针是变量，存放的地址。通过->(成员选择运算符)可以操作指定地址的内存(或 解引用和.运算符)。
			指针和引用的区别:1、指针可以重新赋值或者就行别的运算，而引用不可以(有点像常量指针* const p)。2、引用必须初始化，而指针可以默认初始化(这也有可能出现未定义的情况)。
			引用的作用就是更加符合人们的使用习惯，而且一定程度上确保操作的安全(不会出现指针操作失误引起的野指针等情况，与指针相比)。
const：const限定符的作用就是限定一个变量的值不能改变(因为有的时候我们希望一个变量的值不被改变)。为了这个蛋疼的功能，给C++添加了很多复杂性。
	初始化：由于const变量的值定了以后不能再改变，所以规定const必须(显式)初始化。const变量的初始化和变量的初始化一样，因为从语义上来说，只是变量赋初值而已。
			由于编译期间，编译器可能会把程序中const变量替换成其值，所以每个文件的const变量都应该初始化即定义。为了支持这一用过，const变量是默认只在本文件内有效。
			可以通过extern实现一处实现，多处声明，这样编译器就不会进行值替换。
			
	const引用：表示该引用不会改变其绑定的变量的值。const引用和引用的初始化略有不同：引用初始化时要求引用类型和变量类型严格一致，
			但const引用绑定的对象可以是非const变量(从语义上来说所绑定的对象是不是const对const引用无关紧要)或变量的类型可以转换成引用的类型。
			因为在引用初始化的类型转换中，会先产生一个临时量，然后引用绑定的是这个临时量。
			这个临时量是const的，所以非const引用不能绑定该临时量，但是const引用可以。编译器为了增加引用的使用范围做了一些工作，使const引用看起来使用范围更广。
	const和指针：常量指针表示指针本身是const，指向常量的指针表示指向的变量是个常量。指针赋值，包括const指针初始化，还是主要看所指向的变量类型是否一致(可以进行类型转化)。
	最后，非const引用和非指向const类型的指针不能绑定和指向const变量，const引用和指向const类型的指针可以绑定和指向非const变量。(原因很好理解)
static：将变量存放在全局区，静态全局变量的编译属性会变成仅本文件可见，静态局部变量的定义语句会改成一个类似if判断语句，如果已经定义了就一直使用不会再次定义。

2、表达式：1、包含不同类型表达式，会先转换成统一类型。转换以保证结果最精确为原则。注意：int 会转换成 unsigned int
		   2、优先级：  第一 :: 表示全局作用域、类作用域和命名空间 ；  第二  . -> [] () 结合方向自左向右

3、函数：命名了的代码块。传参分为值传递和引用传递(其实传的是指针)，返回值除了函数和数组都能返回(数组和函数通过指针返回)。
		函数可以重载，注意对于指针或引用： a(int &i);和 a1(const int &i);是不同的函数。调用的时候，编译器会选择最接近的调用。
		
4、类：成员函数添加一个隐形形参this指针。成员函数仍然是一块代码段，不属于类，只是在类的作用域中，并且添加了一个this指针使其与类相关联。
		const成员函数中的const修饰的是this形参，所以类的const对象只能调用const函数。
	构造函数：初始化顺序与类中的出现顺序一样。
	拷贝构造函数：A(const A&)1、类的初始化时(A a2(a1); 或 A a2 = a1;)；2、值传递；3、函数返回非引用对象时。
	赋值拷贝运算符：形参为const A&的赋值运算符重载，A & operator(const A&);
	析构函数：最好为虚函数。
	
	静态成员：静态成员函数是没有this指针的函数。所以其不能调用数据成员除了静态数据成员。
			  静态数据成员，必须在类外进行定义和初始化(或默认初始化)。相当于全局数据成员。在main函数开始前，全局区的数据会完成初始化。
