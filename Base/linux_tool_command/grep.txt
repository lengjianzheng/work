grep是一个用于搜索文本的工具。将匹配的行显示出来。

基本用法：
grep [options] pattern [file]

options：
grep -l 'boss' *   显示所有包含boss的文件名。
2、grep -n 'boss' file在匹配行之前加行号。
3、grep -i 'boss' file显示匹配行，boss不区分大小写。
4、grep -v 'boss' file显示所有不匹配行。
6、grep -c 'boss' file只显示匹配行数（包括0）。
6、grep -r 'boss' * 查找当前目录所有的文件，包括子目录。

pattern：
可以使用正则表达式(还有vim、find、sed、awk也支持RE)
正则表达式常用方法：
1 、 . 代表 任意单个 字符 , 如： /l..e/ 与包含一个 l ，后跟两个字符，然后跟一个 e 的行相匹配
grep ‘ l..e ’ test


2 、 ^ 代表行的开始。 ^love  如 ： 与所有 love 开头的行匹配

grep ^le test

3 、 $ 代表行的结束。 love$  如 ： 与所有 love 结尾的行匹配

那么 ‘^$’  就表示空行

grep  at$ test

4 、 [ … ] 匹配括号中的字符 之一

[abc] 匹配 单个 字符 a 或 b 或 c

[123] 匹配 单个 字符 1 或 2 或 3

[a-z] 匹配 小写 字母 a-z 之一

[a-zA-Z] 匹配任意英文字母 之一

[0-9a-zA-Z] 匹配任意英文字母或数字 之一

注意：不管 [] 里面多复杂，它的结果都是 一个 字符！
grep ‘ l[ae]e ’ test

可以用 ^ 标记做 [] 内的 前缀 ，表示 除 [] 内的字符之外 的字符。比如 搜索 oo 前没有 g 的字符串的行 .  应用 '[^g]oo' 作搜索字符串，
 ^ 符号如果出现 在 [] 的起始位置表示否定 ，但是 在 [] 的其他位置是普通字符 。 [ ^ab^c]  匹配 不是b 或 不是^ 或 不是c 或 不是 a 的任意单个字符

5 、* 用于 修饰 前导字符 ，表示 前导字符 出现0 次 或任意多 次

如： ' a* grep' 匹配所有 0 个或多个 a 后紧跟 grep 的行。 “ .* ”表示任意字符串

6 、 \? 用于 修饰 前导字符 ，表示 前导字符 出现0或1 次

a\?  匹配0或1个a

7 、 \+ 用于 修饰 前导字符 ，表示 前导字符 出现1或多 次

a\+  匹配1或多个a

8 、 \{n,m\} 用于 修饰 前导字符 ，表示前导字符出现 n 至m次 （n和m都是整数，且n<m）

a\{3,5\}  匹配3至5个连续的a

\{n,m\} 还有其他几种形式：

\{n\} 连续的 n 个 前导字符

\{n,\} 连续的 至少n个 前导字符

9 、\ 用于转义 紧跟其后的单个 特殊字符 ，使该特殊字符成为普通字符。(还有别的情况。)

如：^ \.[0-9][0-9]  对 以一个 句点 和两个数字开始

例如：

a*  匹配连续的任意（也包括0）个a

a\?  匹配0或1个a

a\+  匹配1或多个a

a\{3,5\}  匹配3至5个连续的a

\.*  匹配0或多个连续的.  \. 表示普通字符句点


10 、 ｜表示 或    如： a|b|c  匹配 a 或 b 或 c 。如： grep|sed 匹配 grep 或 sed

     如：egrep   ‘ grep|sed ’  test

11 、 （），将部分内容合成一个单位组，比如 要搜索  glad  或  good 可以如下  'g(la|oo)d'

        如： egrep ‘g(la|oo)d’ test
